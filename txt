import json
import datetime
import Project 
import timerecord
import time

class TimeTracker:
    def __init__(self, project):
        """Initialisiert den TimeTracker."""
        self.project = project
        self.start_time = None
        self.end_time = None
        self.duration = None
        self.timerecord = None
        
    def start(self):
        """Starts the time tracker and records the current time as the start time."""
        self.start_time = datetime.datetime.now().isoformat()

    def stop(self):
        """Stops the time tracker and records the current time as the end time."""
        self.end_time = datetime.datetime.now().isoformat()
        self.createTimerecord()

    def createTimerecord(self):
        self.timerecord = timerecord.TimeRecord(self.start_time, self.end_time)
        

    def reset(self):
        """Setzt die Startzeit, Endzeit und Dauer zurück."""
        self.start_time = None
        self.end_time = None
        self.timerecord = None


    def save(self):
        """Speichert die aktuelle Zeitmessung in der aktuellen Projektdatei."""
        self.project.write_time_record(self.start_time, self.end_time)


    import datetime
class TimeRecord:
    def __init__(self, start_time, end_time):
        try:      
            self._start_time = datetime.datetime.fromisoformat(start_time)
            self._end_time = datetime.datetime.fromisoformat(end_time)
            self._duration = (self._end_time - self._start_time).total_seconds() / 60
           
        except :
            self._start_time = None
            self._end_time = None
            self._duration = 0

    @property
    def start_time(self):
        if self._start_time != None:
            return self._start_time.isoformat()
        else:
            return None

    @property
    def end_time(self):
        if self._end_time != None:
            return self._end_time.isoformat()
        else:
            return None

    @property
    def duration(self):
        return self._duration

    def __str__(self):
        return f"Start: {self.start_time} End: {self.end_time} Duration: {self.duration}"

import os
import json
from timerecord import TimeRecord
import shutil
from multipledispatch import dispatch

class Project:
    def __init__(self, name):
        self.name = name
        self.time_records = {}
        self.filename = os.path.join("./projects", f"{name}.json")
        self.load_time_records()

    
    def name(self):
        return self.name
    def create_file(self):
        if not os.path.exists("./projects"):
            os.mkdir("./projects")
            print("Created projects folder")
        if not os.path.exists(self.filename):
            with open(self.filename, "w") as file:
                print(f"Created {self.filename} file")
                
    def write_time_record(self, start_time, end_time):
        time_record = TimeRecord(start_time, end_time)
        self.time_records[time_record.start_time] = time_record
        self.save_to_file()


    def save_to_file(self):
        data = []
        for start_time, time_record in self.time_records.items():
            #after each entry new line
            data.append({
                "start_time":time_record.start_time,"end_time":time_record.end_time})
        with open(self.filename, "w") as file:
            
            json.dump(data, file,indent=4)
        

    def load_time_records(self):
        tempRecords= self.time_records
        try:
            with open(self.filename, "r") as file:
                data = json.load(file)
                for record in data:
                    start_time = record["start_time"]
                    end_time = record["end_time"]
                    time_record = TimeRecord(start_time, end_time)
                    self.time_records[start_time] = time_record
                return self.time_records
        except FileNotFoundError:
            self.create_file()
            self.time_records = tempRecords
            return self.time_records
        except json.decoder.JSONDecodeError:
            print("Input not valid!")
            self.time_records = tempRecords
            return self.time_records
        except Exception as e:
            print(e)

    def get_time_record(self, start_time):
        '''Returns a TimeRecord object from the project'''
        self.load_time_records()
        try:
            return self.time_records[start_time]
        except KeyError:
            return TimeRecord("","")
    def get_time_records(self):
        self.load_time_records()
        return self.time_records

    @dispatch(TimeRecord)
    def delete_time_record(self, time_record):# pyright: ignore
      self.delete_time_record(time_record.start_time)

    @dispatch(str)
    def delete_time_record(self, start_time):
        try:
            del self.time_records[start_time]
            self.save_to_file()
        except Exception as e:
            print(e)

    def get_total_hours(self):
        total_time = 0
        for time_record in self.time_records.values():
            total_time += time_record.duration
            #return total_time in minutes
        return round(total_time,1)

    def print_time_records(self):
        for time_record in self.time_records.values():
            print(time_record)
            
    def get_LastTimeRecord(self):
        if len(self.time_records) == 0:
            return TimeRecord("","")
        else:
            return self.time_records[list(self.time_records)[-1]]
from hashlib import new
import tkinter as tk
from tkinter import ttk, messagebox
from timetracker import TimeTracker 
import datetime
from application import Application

class Gui:
    """Eine Klasse, die eine GUI mit einem Play-Pause-Button und einer Tabelle erstellt."""
    def __init__(self, master, app):   
        self.app = app
        self.tracker = app.current_tracker
        self.project = app.current_project
        self.play_button = tk.Button(master, text="Starten", command=self.on_play_button_click)
        self.play_button.pack()
        self.timetable = ttk.Treeview(master, columns=("date","start", "end", "duration"))
        self.timetable.pack()
        self.clear_button = tk.Button(master, text="Clear", command=self.on_clear_button_click)
        self.clear_button.pack()
        self.hours = tk.Label(master, text="Gesamtstunden: "+str(self.project.get_total_hours()))
        #put the label to the right bottom corner
        self.hours.place(relx=1.0, rely=1.0, anchor='se')
        self.export_button = tk.Button(master, text="Exportieren", command=self.on_export_button_click)
        self.export_button.place(relx=1.0, rely=0.0, anchor='ne')
        self.timetable.heading("#0", text="Datum")
        self.timetable.heading("#1", text="Startzeit")
        self.timetable.heading("#2", text="Endzeit")
        self.timetable.heading("#3", text="Dauer in Minuten")
        # self.swichDropdown = tk.StringVar(master)
        # self.swichDropdown.set("Seit Programmstart")
        # self.progstart = datetime.datetime.now()
        # self.filter = self.progstart
        self.update_table()
        # self.dropdown = tk.OptionMenu(master, self.swichDropdown, "Seit Programmstart","Heute", "Letzte Woche", "Letzter Monat", "Letztes Jahr", "Alle", command=self.dropdown)  # Add command argument
        #place the dropdown menu to the left of the export button
        # self.dropdown.place(relx=0.0, rely=0.0, anchor='nw')
        master.resizable(False, False)
        master.title(self.project.name)


    # def dropdown(self, value):
    #     """Updates the filter attribute based on the selection in the dropdown menu."""
    #     if value == "Seit Programmstart":
    #         self.filter = self.progstart
    #     elif value == "Heute":
    #         self.filter = datetime.datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)
    #     elif value == "Letzte Woche":
    #         self.filter = datetime.datetime.now().replace(hour=0, minute=0, second=0, microsecond=0) - datetime.timedelta(days=7)
    #     elif value == "Letzter Monat":
    #         self.filter = datetime.datetime.now().replace(hour=0, minute=0, second=0, microsecond=0) - datetime.timedelta(days=30)
    #     elif value == "Letztes Jahr":
    #         self.filter = datetime.datetime.now().replace(hour=0, minute=0, second=0, microsecond=0) - datetime.timedelta(days=365)
    #     elif value == "Alle":
    #         self.filter = datetime.datetime(1970, 1, 1, 0, 0, 0, 0)
    #     self.update_table()



    def on_export_button_click(self):
        """Wird aufgerufen, wenn der Export-Button gedrückt wird."""
        messagebox.showinfo("Exportieren", "Exportieren in Arbeit")

    def on_clear_button_click(self):
        """Wird aufgerufen, wenn der Clear-Button gedrückt wird."""
        if self.tracker.start_time is not None:
            tk.messagebox.showerror("Fehler", "Der Tracker läuft bereits.")
            return
        if messagebox.askyesno("Sitzung zurücksetzen?", "Tabelle leeren (Daten werden nicht gelöscht)? "):
            self.timetable.delete(*self.timetable.get_children())
            self.filter = datetime.datetime.now()

    def on_play_button_click(self):
        """Wird aufgerufen, wenn der Play-Button gedrückt wird."""
        if self.tracker.start_time is None:
            # Erfasse die aktuelle Zeit als Startzeit und speichere sie in der JSON-Datei
            self.tracker.start()
            self.timetable.insert("", "end", text=self.tracker.start_time, values=(self.tracker.start_time, "", ""))
            self.play_button.config(text="Stoppen")
            self.play_button.config(command=self.on_pause_button_click)



        else:
            # Der Tracker läuft bereits, also zeige eine Fehlermeldung
            tk.messagebox.showerror("Fehler", "Der Tracker läuft bereits.")

    def on_pause_button_click(self):
        """Wird aufgerufen, wenn der Pause-Button gedrückt wird."""
        if self.tracker.start_time is not None:
            # Erfasse die aktuelle Zeit als Endzeit und berechne die Dauer
            self.tracker.stop()
            self.tracker.save()
            self.tracker.reset()
            self.play_button.config(text="Starten")
            self.play_button.config(command=self.on_play_button_click)
            self.update_table()

        else:
            # Der Tracker läuft nicht, also zeige eine Fehlermeldung
            tk.messagebox.showerror("Fehler", "Der Tracker läuft nicht.")



    def update_table(self):
        self.timetable.delete(*self.timetable.get_children())



        
    

def main():
    # Erstelle ein Fenster
    window = tk.Tk()
    newApp = Application()
    newApp.select_project("Test")
    window.title(newApp.current_project.name)

    # Erstelle eine Instanz von TimeTrackerGUI und übergebe das Hauptfenster und den Tracker
    gui = Gui(window, newApp)

    # Starte die GUI
    window.mainloop()

    

if __name__ == "__main__":
    main()    
import os
from Project import Project
import timetracker as timeTracker


class Application:
    def __init__(self):
        self.projects = {}
        self.load_projects()
        self.current_project = None
        self.current_tracker = None

    def current_project(self):
        return self.current_project
    def current_tracker(self):
        return self.current_tracker


    def load_projects(self):
        project_filenames = os.listdir("./projects")
        for filename in project_filenames:
            name, _ = os.path.splitext(filename)
            project = Project(name)
            self.projects[name] = project
            print(f"Loaded project {name}")

    def add_project(self, project):
        self.projects[project.name] = project

    def get_project(self, name):
        return self.projects.get(name)

    def get_total_duration(self):
        total_duration = 0
        for project in self.projects.values():
            for time_record in project.time_records.values():
                total_duration += time_record.duration
        return total_duration

    def select_project(self, project_name):
        project = self.get_project(project_name)
        if project:
            self.current_project = project
            self.current_tracker = timeTracker.TimeTracker(self.current_project)
        else:
            print(f"Project {project_name} not found")

    def change_current_project(self, name):
        self.current_project = self.get_project(name)
        if self.current_project is None:
            self.current_project = Project(name)
            self.add_project(self.current_project)
        print(f"Changed current project to {self.current_project.name}") 







